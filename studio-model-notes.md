The studio: a model for empowerment and productivity. 

Developer productivity 

A developer is one of the most expensive line items in product development, usually far more than other roles and operational costs. It follows that trying to measure and optimize your developers’ productivity is an important step for any engineering organization. So why does it prove to be so challenging, or even counterproductive? 

I often see developer productivity initiatives using an outdated view of software development – treating it like a factory line. In this model, we reduce the worth of a developer to write code to fulfill predetermined requirements; a coding robot to churn out new pages and widgets. It is appealing to think of software developers in this way, it makes it easy to quantify, we can just measure how fast developers are completing their assigned tasks. 

There are parts of development that are “factory like” repetitive, low value tasks that should be standardized, and completed to an exacting quality every time. However the difficult part of software product development, designing and building something new and novel that delights customers, is not standardized or automatable, and this is where effective developers spend their energy. 

Metrics like developer velocity, pull request rate, and number of merges, are popular measurements of developer productivity. These metrics provide signals to derive insights on efficiency, but they reflect a portion of the developer lifecycle and tell you little about the quality, outcome and invention of what is being produced. If we overemphasize these metrics, and don’t take into account other signals, we can inadvertently incentivize the wrong outcome – a lot of code and software that doesn’t create value for our customers. 

It's no longer possible to hire your way out of productivity problems. The industry has turned the focus to efficiency and productivity. Companies like Google and Meta publicly discussed it as a business strategy. There has been an explosion of innovative tools that offer increased productivity as a benefit, such as AI-based coding assistants, engineering management platforms, and developer portals. Companies are sponsoring productivity initiatives, tasking platform engineering teams and front line managers to find improvements. 

Developer productivity initiatives using an outdated view of software development – treating it like a factory line. In this model, we reduce the worth of a developer to write code to fulfill predetermined requirements; a coding robot to churn out new pages and widgets. It is appealing to think of software development in this way, it makes it easy to quantify, we can measure how fast developers are completing their assigned tasks. 

There are parts of development that are “factory like” repetitive, low value tasks that should be standardized, and completed to an exacting quality every time. However the difficult part of software product development, designing and building something new and novel that delights customers, is not standardized, can’t be automated and this is where effective developers spend their energy. 

Metrics like developer velocity, pull request rate, and number of merges, are popular measurements of developer productivity. These metrics provide a signal to derive insights on efficiency, but they solely reflect a part of the developer lifecycle and tell you little about quality, outcome and invention of what is being produced. If we overemphasize these metrics, and don’t take into account other signals, we can inadvertently incentivize the wrong outcome – a lot of code and software that doesn’t create value for customers. 

Influenced by the success of nimble startup and lean methodology, the modern approach to building great software products is through evolution – trying ideas we think will be valuable, failing to find traction with customers, pivoting, failing again and continuously iterating until finally making a breakthrough. It involves using the collective creativity of the whole team to find solutions within constraints. Embracing a “fail fast” mentality, encouraging rapid experimentation and learning about a problem space. If we are serious about improving developer productivity we need to enable this approach, it isn’t enough just to focus on removing friction and speeding up. 
What do developers produce?

When metrics are discussed there is very little conversation about what we are actually paying developers to do, only that developers are “productive”. It is implied that the role of the developer is to output code. While a developer does spend a significant portion of their day writing code, they are not trying to produce code, they are trying to produce software – working software that solves a customer problem. Code is a vital ingredient, yet it’s one element of a larger equation.  

While speeding up the tasks associated with coding, coding, integration, testing, knowledge discovery, incredibly important. I myself talked about it in my developer effectiveness article. We also need to look at the outcomes we are trying to achieve, to give us more insights into improving developer productivity. 

Valuable software
As 1,000 failed startups know, just because we built software, doesn’t mean anyone will use or pay for it. Finding ideas that are useful to customers, isn’t purely the job of the product manager or “the business”. Developers have an important contribution, and it is often overlooked. 

Releasable software
A customer should be able to utilize our software. While this seems obvious, a good question to ask is how much of your current software product is truly accessible by a customer? Often large swatches aren’t released. These unreleased features are akin to inventory in a store room with a limited shelf life. They provide no value, and there is only a finite period a customer is willing to pay for a product before turning to an alternative. In order to keep code up to date, the best developers shape their work and configure the software so that it can be incrementally released and quickly put in the hands of end users safely. 

Efficient software
Making software efficient includes the operating costs, cloud services, supportability costs. Developers make large and small trade-offs decisions as they build that will affect its operational efficiency.  Efficiency also applies to the amount of code we accumulate. Code is expensive for the company, it has to be maintained, supported and tested. Ideally instead of writing code developers should use the wide range of building blocks open to them, cloud services, internal capabilities, SaaS products, and open-source libraries. 

Evolvable software
The developer is not just completing the feature they are working on, they are making it easy to modify and extend in the future, usually by someone else. Custom code can last for over 10 years. We’re all too familiar with technical debt being cited as the reason why a team can’t accelerate. Developers spend a lot of time designing software,to be easy to understand, support, and modify. This happens initially and as the product evolves, with every change. They create a safety net. – testing, observability and resilience practices, and documentation for future developers. This gives the developer the confidence to  change and refactor with confidence they won’t break the software. 

Reliable Software
Our applications need to be able to adapt with the demands of the customer, now and in the future. Two of the most important reliability traits are performance, security and availability. When introducing new functionality developers must ensure they haven’t haven’t added a scaling bottleneck or heightened risk of an outage. Whether it's a sudden surge in traffic due to a viral campaign, or the need of immediate patching in response to a known vulnerability, the software needs to easily handle such scenarios. The best developers think through edge cases, prioritize simple scalable often that will be used to support., The developer adds telemetry, we can learn quickly the cause of an issue and quickly fix it. 

These 5 elements are major qualities, common in every project. There are many other important qualities a developer should be concerned about, that we could write about e.g  accessibility and compliance. The developer can make tradeoffs across all of these elements. They all exist in a spectrum and are applied in different ways for stages of a product. For example in earlier stages we are more concerned with testing ideas, later stages we are more concerned with efficiency.  Also the level of seniority affects it greatly, a junior developer will apply the elements within their task and a seasoned developer more broadly across their product. 

A productive developer will find the best way to make an impact, sometimes it is heads down coding a complex feature quickly, another might collaborating with design colleagues on creating a simpler UI workflow, or pairing with less senior developers to bring them to speed. To increase productivity we need a culture that provides developers with the information, processes and the tools they need, and rewards developers for making the biggest contribution to the impact of the software product, not to an immaterial output metric. 
Factory vs Studio Model 

A way to represent these two views of software development (the outdated view and the modern one), is a Factory vs Studio model. In a factory model, like a car manufacturing, we are building the same product over and over to a high quality from a detailed specification. A studio model, such as creating a film, is a group of creative people collaborating towards a product that delights the customer and generates value for our business. The Studio in my mind is a more valid metaphor for software development, where the product we are creating doesn't already exist and is new and novel. To apply the studio model to software product teams, this diagrams shows major differences we see in approaches, from the perspective of the developer: 

Factory Model
Studio Model 
Developers have little understanding of customer needs
Developers have deep understanding of customer personas, frustrations and motivations 


Little quantification of product goals into metrics and indicators
Product strategy has clear goals, with leading and lagging indicators
Developers have little understanding of the company business
Developers are experts in their product’s field, understand the company goals and principles
Progress is tracked by strict roadmap of features 


Progress is tracked via value delivered to customers, the team pivots when value isn’t being produced.
Requirement come from outside the team – sales, leadership, “the business” 
Ideas can come from anyone, including developers
Cross functional interactions are handoffs 
Technologists (product, design, data & developers, etc) collaboration closely on design and build 



Developers have deep understanding of customer personas, frustrations and motivations 

The Factory model relies on product managers and business analysts to handle the interactions with the customer and the rest of the company. The developer doesn’t need to concern themselves with distractions like talking to a user of the product they are building, they should focus their time on what they are good at – coding. The features are presented to developers with lengthy requirement documents; there doesn’t need to be interaction with the analyst until the feature is done, and ready for approval. You might think I am describing a waterfall scenario, from a previous era of the technology industry. But yet, I encounter this anti pattern all the time, even with teams that have subscribed to Agile and Lean methodologies. The stories are overly documented with acceptance criteria, details and pixel perfect designs, and there is little discussion. The customer is a faraway abstract concept to the development team. 

In the studio model, we start with the principle that developers can build empathy for the customer, as they are humans too and can understand their wants and needs. When developers have a strong understanding of the customer, they are empowered to make many of the product decisions themselves. Requirements no longer need to be lengthy documents detailing every aspect. To foster this understanding, user research should be easily accessible to developers, outlining customer issues and needs. Every developer on the product team should have the opportunity to observe customers using the product and engage in conversations with them about their experience.


Developers are experts in their product’s field, understand the company goals and principles

Along with Customer understanding, understanding of the business domain and customer mission, is just as important, and similarly not often prioritized. When I find a confusing coding requirement, and I ask the team where did it came from? I would often get the answer “The Business”. What is this mythical department?  Hearing this is an indication of the Factory Model, the reasons and justification for feature requirements are not going to be explained (if it even exists). That is beyond the comprehension of a mere developer. 

Modern tech companies don’t have a distinction between the business and the product development team, the product team is built so it is equipped with enough experience, skills, to be able to do research, come up with requirements, build them and to assess the results. Merging business and technology is a well known modernization concept, but I have found the merging often stops short of the development team. 

The company strategy should be clear, the company’s mission, how the company plans to generate revenue and investment. The principles and tenets of the company’s philosophy should be well known by everyone. In the studio model we empower developers by giving the context to make decisions. Knowing the business strategy encourages atomony. If the product team, including developers, can make their own assessment of a framework of what is right for the company by referring to the published strategy, rather than having to consult upper management they become far more productive. 

Over time, they are expected to become experts in their product’s field, whether that’s finance, health, or music streaming. They don’t solely rely on industry experts; instead, they combine their business acumen with a deep understanding of customer needs to inform their decisions and generate ideas. There isn’t an overreliance on external SMEs; they do not blindly follow requirements. They can identify when something seems off and isn’t working and raise concerns. As a result, the software produced by the team is more useful for customers, the design is easier to understand and to flex to handle future change better. 

Short milestones, regular feedback loops, the team pivots when value isn’t being produced.
Building the wrong product—one that doesn’t provide value—is by far the biggest cause of wasted productivity. Long projects that follow rigid plans with minimal feedback often lead to features that don’t have the expected impact, or worse, aren’t even used. The team may have impressive delivery statistics and be following Agile practices, but if their energy is spent in the wrong ways, it’s all for nothing. To avoid this, the studio model fosters a culture of experimentation—where teams are encouraged to test new ideas, admit failure when things don’t work, and pivot quickly.
The factory model doesn’t work because, unlike car manufacturing, we don’t know exactly what customers will pay for or what to build. A common anti-pattern I see is teams treating their backlog of requirements as guaranteed value creators. It’s better to treat these requirements as hypotheses. Until users are actually using or paying for your service, the hypothesis remains unvalidated.
Loss aversion, a concept in behavioral psychology, makes people naturally risk-averse, especially when the potential reward is low and the risk involves significant loss. We have to combat this tendency to be naturally conversations. The best companies strike a balance by taking acceptable risks and encouraging innovation without being overly conservative.
The studio model counters this by maintaining a close feedback loop with customers. Teams challenge themselves to design experiments that test ideas in the leanest, quickest way possible to learn rapidly. Failure is celebrated as a learning opportunity, allowing teams to quickly discard unsuccessful experiments and move on to better ideas.
The key advantage here is the continuous delivery of value. By building incrementally with small batch sizes and short feedback loops, we can completely transform how we measure progress. When we have far away deliverables, 6 months, or even, a year long, it is too much to be able to reason about, so we have to resort to tracking progress with delivery metrics, we have little other information.  Small milestones allow the team to reason through changes, make trade-offs, and move away from hypothetical scenarios. With real data, decisions are based on facts, enabling the team to optimize for business outcomes.
Progress is tracked via value delivered to a customers

I once worked on a project were the team thought they were doing Agile practices well, the team was following all the right processes. They were capturing story estimates every iteration, running standups, showing a burn down with a healthy trend line. The showcases started with these abstracts charts that were impressive, but i missed what has the the team had delivered for the customers and what did those customers think of the product. How are our experiments progressing. Instead we changed product showcases to lead with this information. 

Ideas can come from anyone, including developers, are validated before pursuing 
I often speak with companies that feel they have a top-down culture, where ideas seem to appear out of nowhere and are handed down to developers. On the other hand, I’ve also seen the opposite problem, where developers are given too much freedom and end up spending excessive time on vanity projects. The key is recognizing that anyone can have a valid idea. Developers, for instance, spend a lot of time using and thinking about the software they build, which naturally leads to new ideas. The executive team exists for a reason—they should have strong intuition. And the product team spends the most time interacting with customers. The issue isn’t about simply taking an idea and completing it.
Often, the creative energy from developers isn't fully harnessed. By rewarding developers based on the impact they have on customers and the quality of the software they create—rather than just meeting deadlines—we can start to tap into new ideas. More modern companies have processes in place that allow ideas to flow and be explored effectively.

Technologists (product, design, data & developers, etc) collaboration closely on design and build 

A key principle in the studio is to behave like a team of equals,, focusing less on specialization and the rigid boundaries of roles. It’s perfectly fine for developers to conduct research or come up with product ideas. While expertise is still essential, it shouldn’t be encoded to rigid workflows with strict handoffs. The best ideas emerge when developers and designers collaborate closely, iterating on designs, considering trade-offs, and refining them together, rather than working solely from a pixel-perfect spec. We aim to create an environment that fosters innovation, quick iteration, idea exchange, and experimentation, all while validating the usefulness of these ideas with customers.
Platform Engineering 
While we like to think of the product development as being very open and flexible, platform engineering on the other hand the factory model fits very well. We want to maintain the flow through the system, with the least amount of moving parts and manual interventions. Quality is maintained, defects are an opportunity for learning and to improve the factory's systems. Experiments can be run safely with a flow of data coming back. It is these dependable capabilities that the product developers can rely on as they innovate. 

Summary

Why write this essay now? with the rapid explosion of GenAi, has created a lot of conversations around measuring developer productivity. We are having a lot of conversation about metrics, I thought we had long put it bed (). A lot of the current developer models I see at companies are designed around that coding is tedious, there is a lot to slog through and we need to focus our developer on this. As GenAI remove the boiler plate code, the long research to find the function your need. It opens up the questions of the developer. They should have more cognitive energy to focus on the quality and invention of the product, more like a product manager. It's important to create a culture the empowers developers to think like this. It is imperative that we look at our developer model to make sure we realize the potential of the developers we have. A good way to start is to ask yourself these questions: 










——-


In my previous article on maximizing developer effectiveness, I emphasized the need for a fast developer environment, and I still firmly advocate for this as it forms the underlining capability of efficiency. When developers are faced with a myriad of interruptions, bureaucracy, and rework, their focus is fragmented. However, mere speed and output are insufficient. To find out how to optimize the developer experience, we must consider the developer's role within a holistic product development process.


Factory Model
Studio Model 
Developers have little understanding of customer needs
Developers have deep understanding of customer personas, frustrations and motivations 
Developers have little grasp of the business domain and mission
Developers are experts in the domain of the product and understand the company goals 
Progress is tracked by strict roadmap of features 
Progress is tracked via value delivered to customers
Little quantification of product goals into metrics and indicators 
Product strategy has clear goals, with leading and lagging indicators
Long project, Few checkpoints for feedback with customers and stakeholders
Short milestones, regular feedback loops, the team pivots when value isn’t being produced. 
Cross functional interactions are handoffs 
Technologists (product, design, data & developers, etc) collaboration closely on design and build 
Progress metrics are focused on output (code & features.)
Use delivery metrics, to keep pace and focus
Ideas only come from  disconnected individuals – e.g. upper hierarchy, sales, “the business”
Ideas can come from anyone, including developers, are validated before pursuing 



Cassie’s Model 


Building the wrong thing – a product that is not valuable – is far and away the biggest cause of productivity waste. A long projects following rigid plans with little feedback points. Results in product features not having the expected impact, and at worst are not even used. The team may have had amazing delivery statistics and be embracing Agile practices, but the team’s energy is being wasted, applied in the wrong ways. To avoid this the studio model embraces an experimentation culture; The ability to try many new ideas, admit failure when it doesn’t work, and pivot quickly.

The reason a factory model doesn’t work, is that unlike a car, we don’t know exactly what a customer will pay for, and what to build. An anti-pattern I often see is teams treating ideas, a backlog of requirements, as guaranteed value creators. It is better to think of requirements as hypotheses, until the user is actually using or paying for your service, the hypothesis is unvalidated. 

Loss aversion, a human trait in behavioral psychology, makes individuals naturally conservative, opting for safe choices, especially when the potential reward is low, and the risk involves significant loss. The best companies balance an acceptable risk, encourage innovation, to try new things, avoiding being overly conservative. 

With the Studio model attempts to avoid this, they have a close feedback loop to the customers. The team challenges themselves on how to design an experiment to test out an idea in the leanest way possible, to learn quickly. They celebrate failure, as a learning, quickly discarding the experiment and moving on to a better idea. 

The super power that enables is continuous delivery of value. Building in an incremental way, small batch sizes and short feedback loops. This completely changes the way we can measure progress. It allows the team to think in small milestones. When we have far away deliverables, 3 or 6 months, or even, a year long, it is too much to be able to reason about, so we have to resort to tracking progress with delivery metrics, but we have little other information. With the short milestone the team can reason about it change, they can make tradeoffs, there is less hypothetical. We have real data to make decisions this unlocks the ability to optimize to business outcomes. 


Another typical problem, common in SaaS solutions is the divide between the product developer and those implementing the software (field engineers). While necessary for scalability, this divide means that product developers aren’t gathering useful insights from customer interactions. This can be addressed by having the product developers shadow the field developers, or rotate into that role. Often they discover the implementation team has resorted to workarounds, compensating for product weaknesses that can be fixed easily with minor adjustments.  

Having deep SMEs are important, often they are the ternuried members of the team or a industry expert, overrlying them to perform all the research and write all the requirements, disempowers the development team. Having been a consultant for many years, my special skill was quickly learning a business, this would be done by reading industry books and publications, talking to in-house experts, looking at competition products, reading documentation and tests, and using the product myself. 

In a similar way to understanding the customer, if they understand about the field that the product is operating in then the developer is in a better position to make decisions. 

In order to give all employees a purpose, not just developers they should have some understanding of the goals and the principles of the company. If we can apply this, it helps to avoid a top down approach. Rather than being opaque a developer should understand how a feature contributes to the strategy of the company.  we can ask for reasoning and push  when a feature doesn’t seem to align with the company strategy. It is important the the developers understands why they are building something. 


















Value: Progress is tracked via value delivered to customers
Recently, I worked with a team that was well-versed in Agile metrics and began producing metrics they believed would be a good way to track progress: Velocity, Burndown, cycle time, and others. During the showcase, The CTO asked a question: "What have you delivered for our customer? And are they getting value from this?". The team subsequently changed their reporting during showcases to show the features , they still show delivery efficiency metrics but they were secondary. 
In making this small change, what it did is show that everyone is responsible for making sure value is delivered to customers, challenges how the team approaches the problems. Everything they do has to underthe service of delivery value. It is not just the purview of the product or sales team, the developer is actually critical in making sure features are delivered to customer, and those feature are actually valuable to the customer. Often I see these two functions are separate the development is tracked with delivery metrics, and the product team is tracking the value separately, this causes inefficiencies. If we focus the team on value, then every decision is assessed on what is the fastest way 
It is why continuous delivery is so important, with long projects, with few release, the value to the customer so far off, the only metrics we can track are the delivery efficiency metrics, so leads to use spending a lot of 

Optimize Time to Learning: Short milestones, regular feedback loops, the team pivots when value isn’t being produced.

Building the wrong thing – a product that is not valuable – is far and away the biggest cause of productivity waste. A long projects following rigid plans with little feedback points. Results in product features not having the expected impact, and at worst are not even used. The team may have had amazing delivery statistics and be embracing Agile practices, but the team’s energy is being wasted, applied in the wrong ways. To avoid this the studio model embraces an experimentation culture; The ability to try many new ideas, admit failure when it doesn’t work, and pivot quickly.

The reason a factory model doesn’t work, is that unlike a car, we don’t know exactly what a customer will pay for, and what to build. An anti-pattern I often see is teams treating ideas, a backlog of requirements, as guaranteed value creators. It is better to think of requirements as hypotheses, until the user is actually using or paying for your service, the hypothesis is unvalidated. 

Loss aversion, a human trait in behavioral psychology, makes individuals naturally conservative, opting for safe choices, especially when the potential reward is low, and the risk involves significant loss. The best companies balance an acceptable risk, encourage innovation, to try new things, avoiding being overly conservative. 

With the Studio model attempts to avoid this, they have a close feedback loop to the customers. The team challenges themselves on how to design an experiment to test out an idea in the leanest way possible, to learn quickly. They celebrate failure, as a learning, quickly discarding the experiment and moving on to a better idea. 


Peers : Technologists (product, design, data & developers, etc) collaboration closely on design and build 


If we are expecting developers to make the most impact for the product outcomes, they need to have enough context to be able to prioritize what is important for the customer. A common source of engineering waste is through rework from building to the wrong understanding. Typically this is a wrong idea about the product goals and customer desires. It is particularly problematic when isn’t tight feedback loops, as the problem will be discovered later. 

Another misunderstanding is over engineering, creating something overly complex for a hypothetical situation, that the product hasn’t reached yet, and there isn’t enough indication it will. Examples of over engineering, include creating a very finely grained architecture, that would scale amazingly, but comes at a cost of development productivity. Another example is a complicated object model that lets the code be extended and manipulated in many ways, but the current use case is very simple. 

The studio model encourages collaboration during design and build, and transparency of the product, business domain and metrics. This avoids the engineering waste. The developer with a better understanding and ready access to information is better placed to make decisions. They also work with peers closely during the design and build phase. A data analyst can provide projected usage, ROI and design experiments. The product manager will help on deciding SLAs and making decisions for trade-offs. Designers pair with developers to make changes to the UX. 

The team is not working overly specific requirement documents, they know about the product goals the metrics they are trying to affect. This encourages creativity, if there is a better way to achieve a goal, the team can try it, challenging themselves about how to validate that feature in the fastest way. A Factory model does not allow for this, as the requirements and plan is fixed, and there isn’t close collaboration. 

Urgency and Focus: Balance of delivery, friction and outcome based metrics. 

Empowerment doesn’t mean without accountability. Keeping developers accountable within a structure is crucial for maintaining high productivity. With the desire to have autonomous teams with minimal dependencies, regimented processes aren't prescribed. This puts a burden on the front-line managers and senior members of the team to put in an efficient process. 

I found that engineering functions lacking delivery disciple, exhibit these problems: 
Little planning: business leaders don’t have a clear understanding of when a feature or product will be delivered to the customer
Overcommitment: too many things being worked on, team is continually over promising and missing deadlines.
Lack of consistency: creates challenges for teams to collaborate and developers to change teams
Reinventing the wheel: teams independently embark on building competing capabilities. 

Our recommendation is to create a delivery process and tracking mechanism that gives structure, focus, and keeps pace. The accountability should allow developers to thrive, and facilitates continuous improvement.

A common initial tactic is to adopt industry-established practices proven to impact business performance in various organizations (Spotify team model, DORA 4 key metrics, Agile frameworks). It's essential to recognize that these practices originate from companies likely facing distinct challenges and cultural contexts. A mistake is to mindlessly follow them, without assessing if they are hitting your expected outcomes.  

A key delivery asset is to have a view on what good delivery looks like for your company. This is best practises harvested from industry and what your most effective teams are doing. We recommend creating a delivery blueprint – the principles, rituals, tools and process, that a new team can start with, and diverge from as they become more mature. 

Delivery oriented metrics are helpful to keep pace, accountability and a focus to the team. We should not mistake these metrics for a measure of productivity. They don’t tell us about the quality and the outcome of the product being delivered. We want to avoid the situation where a team is more concerned about hitting delivery numbers, than building the most valuable product for our customers, which is why short milestones and frequent customer feedback is so important. 

A lot of the delivery metrics cannot be compared across teams. Inherently teams are different, they are shaped completely differently with varying goals, skills and experiences. A team that is working on a product with a lot of tech debt, versus a green field team will have completely different delivery challenges. The nature of the product further increases diversity – a team building a ML based search is not comparable to a team doing a customer sign up flow. Recently, we've noticed a concerning trend where aggregate delivery metrics are presented devoid of context. To derive meaningful insights, metrics have to be shared with context, anecdotes, and opinions. A better approach is to watch trends, when a metric is changing unexpectedly, explore why, and with an open mind, as it may not be a bad thing. 


Product strategy has clear goals, with leading and lagging indicators




